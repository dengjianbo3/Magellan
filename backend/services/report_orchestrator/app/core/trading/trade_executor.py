"""
Trade Executor - Trade Execution Specialist

Responsibilities:
1. Receive Leader's decision instructions (TradingSignal)
2. Perform secondary validation (account status, position check)
3. Execute actual trading tool calls
4. Return execution results

Architecture:
- Leader: Decision maker (generates TradingSignal)
- TradeExecutor: Executor (executes TradingSignal)
- Follows Single Responsibility Principle and Separation of Concerns
"""

from typing import Dict, Any, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


class TradeExecutor:
    """
    Trade Execution Specialist

    Responsible for executing Leader's trading decisions, including:
    - Secondary validation of decision reasonableness
    - Checking account status and risk limits
    - Calling actual trading tools
    - Recording detailed execution logs
    """

    def __init__(self, toolkit, paper_trader=None):
        """
        Initialize TradeExecutor

        Args:
            toolkit: TradingToolkit instance with execution tools
            paper_trader: PaperTrader instance for direct execution (optional)
        """
        self.toolkit = toolkit
        self.paper_trader = paper_trader
        self.name = "TradeExecutor"
        self.id = "TradeExecutor"

        logger.info(f"[{self.name}] Initialized with toolkit: {type(toolkit).__name__}")

    async def execute_signal(
        self,
        signal: 'TradingSignal',
        position_info: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Execute trading signal

        Execution flow:
        1. Validate signal completeness
        2. Check account status
        3. Check position conflicts
        4. Execute trading tools
        5. Return execution result

        Args:
            signal: Trading signal generated by Leader
            position_info: Current position info (including position, account, limits, etc.)

        Returns:
            Execution result dict {
                "status": "success" | "rejected" | "error",
                "action": "opened_long" | "opened_short" | "hold" | ...,
                "reason": "...",
                "details": {...}
            }
        """
        logger.info(f"[{self.name}] ========================================")
        logger.info(f"[{self.name}] Received Leader's trading decision")
        logger.info(f"[{self.name}] Decision direction: {signal.direction}")
        logger.info(f"[{self.name}] Confidence: {signal.confidence}%")
        logger.info(f"[{self.name}] ========================================")

        # Step 1: Validate signal completeness
        validation_result = self._validate_signal(signal)
        if not validation_result['valid']:
            logger.error(f"[{self.name}] âŒ Signal validation failed: {validation_result['reason']}")
            return {
                "status": "rejected",
                "action": "validation_failed",
                "reason": validation_result['reason'],
                "details": {}
            }

        logger.info(f"[{self.name}] âœ… Signal validation passed")

        # Step 2: Check account status
        account_check = await self._check_account_status()
        if not account_check['ok']:
            logger.error(f"[{self.name}] âŒ Account check failed: {account_check['reason']}")
            return {
                "status": "rejected",
                "action": "account_check_failed",
                "reason": account_check['reason'],
                "details": account_check
            }

        logger.info(f"[{self.name}] âœ… Account status OK")

        # Step 3: Check position conflicts (if opening position)
        if signal.direction in ["long", "short"]:
            conflict_check = self._check_position_conflict(signal, position_info)
            if conflict_check['has_conflict']:
                logger.warning(f"[{self.name}] âš ï¸ Position conflict: {conflict_check['reason']}")
                return {
                    "status": "rejected",
                    "action": "position_conflict",
                    "reason": conflict_check['reason'],
                    "details": conflict_check
                }

            logger.info(f"[{self.name}] âœ… No position conflict")

        # Step 4: Execute trading tools
        logger.info(f"[{self.name}] ðŸš€ Starting trade execution...")

        try:
            execution_result = await self._execute_trade(signal)

            if execution_result.get('status') == 'success':
                logger.info(f"[{self.name}] âœ… Trade execution successful!")
                logger.info(f"[{self.name}] Action: {execution_result.get('action')}")
                logger.info(f"[{self.name}] Details: {execution_result.get('details', {})}")
            else:
                logger.error(f"[{self.name}] âŒ Trade execution failed: {execution_result.get('reason')}")

            return execution_result

        except Exception as e:
            logger.error(f"[{self.name}] âŒ Trade execution exception: {e}", exc_info=True)
            return {
                "status": "error",
                "action": "execution_error",
                "reason": f"Execution exception: {str(e)}",
                "details": {}
            }

    def _validate_signal(self, signal: 'TradingSignal') -> Dict[str, Any]:
        """
        Validate signal completeness

        Checks:
        - direction is not empty
        - confidence is in valid range
        - If opening position, leverage/amount_percent must be valid
        - Take profit/stop loss prices must be set
        """
        if not signal.direction:
            return {"valid": False, "reason": "Decision direction is empty"}

        if signal.direction not in ["long", "short", "hold", "close"]:
            return {"valid": False, "reason": f"Unknown decision direction: {signal.direction}"}

        if not (0 <= signal.confidence <= 100):
            return {"valid": False, "reason": f"Confidence out of range: {signal.confidence}"}

        # If opening position, check parameters
        if signal.direction in ["long", "short"]:
            if signal.leverage < 1 or signal.leverage > 20:
                return {"valid": False, "reason": f"Invalid leverage: {signal.leverage}"}

            if signal.amount_percent <= 0 or signal.amount_percent > 100:
                return {"valid": False, "reason": f"Invalid position percent: {signal.amount_percent}%"}

            # Check TP/SL
            if signal.take_profit_price <= 0 or signal.stop_loss_price <= 0:
                return {"valid": False, "reason": "Take profit/stop loss prices not set"}

        return {"valid": True, "reason": ""}

    async def _check_account_status(self) -> Dict[str, Any]:
        """
        Check account status

        Checks:
        - Account is available
        - Balance is sufficient (at least 10 USDT for trading)
        """
        if not self.paper_trader:
            # If no paper_trader, use toolkit to get account info
            # Simplified here, pass by default
            logger.warning(f"[{self.name}] No paper_trader provided, skipping detailed account check")
            return {"ok": True, "reason": ""}

        try:
            # FIX: Use correct method name get_account() instead of get_account_status()
            account = await self.paper_trader.get_account()
            available_balance = account.get('available_balance', 0)

            # Check if balance is sufficient
            min_balance_required = 10  # At least 10 USDT
            if available_balance < min_balance_required:
                return {
                    "ok": False,
                    "reason": f"Insufficient balance: {available_balance:.2f} USDT < {min_balance_required} USDT",
                    "available_balance": available_balance
                }

            return {"ok": True, "reason": "", "available_balance": available_balance}

        except Exception as e:
            logger.error(f"[{self.name}] Failed to check account status: {e}", exc_info=True)
            return {"ok": False, "reason": f"Account check exception: {str(e)}"}

    def _check_position_conflict(
        self,
        signal: 'TradingSignal',
        position_info: Optional[Dict]
    ) -> Dict[str, Any]:
        """
        Check position conflicts

        Checks:
        - Whether there's an existing position (if so, can't directly open new position)
        - Whether position direction conflicts with signal

        Args:
            signal: Trading signal
            position_info: Position info {
                "has_position": bool,
                "current_position": {...},
                "can_add": bool,
                ...
            }
        """
        if not position_info:
            # No position info provided, assume no conflict
            return {"has_conflict": False, "reason": ""}

        has_position = position_info.get('has_position', False)

        if not has_position:
            # No position, free to open
            return {"has_conflict": False, "reason": ""}

        # Has position, check for conflicts
        current_position = position_info.get('current_position', {})
        current_direction = current_position.get('direction', '')

        # If opening same direction, check if adding is allowed
        if signal.direction == current_direction:
            can_add = position_info.get('can_add', False)
            if not can_add:
                return {
                    "has_conflict": True,
                    "reason": f"Already have {current_direction} position and reached max position limit, cannot add"
                }
            # Can add
            return {"has_conflict": False, "reason": "Can add to position"}

        # If opening opposite direction, this is a conflict
        if signal.direction in ["long", "short"]:
            return {
                "has_conflict": True,
                "reason": f"Already have {current_direction} position, cannot directly open {signal.direction}. Please close first or use reverse operation."
            }

        return {"has_conflict": False, "reason": ""}

    async def _execute_trade(self, signal: 'TradingSignal') -> Dict[str, Any]:
        """
        Execute actual trading operation

        Based on signal.direction, call corresponding tool:
        - long: open_long
        - short: open_short
        - hold: hold (no execution)
        - close: close_position
        """
        direction = signal.direction

        logger.info(f"[{self.name}] Executing {direction} operation")

        # Hold - Wait
        if direction == "hold":
            return {
                "status": "success",
                "action": "hold",
                "reason": signal.reasoning or "Hold, waiting for better opportunity",
                "details": {
                    "confidence": signal.confidence,
                    "reasoning": signal.reasoning
                }
            }

        # Close - Close position
        if direction == "close":
            if self.paper_trader:
                result = await self.paper_trader.close_position(
                    reason=signal.reasoning or "Leader decision to close"
                )
            else:
                # Use toolkit
                close_tool = self.toolkit._tools.get('close_position')
                if not close_tool:
                    return {
                        "status": "error",
                        "action": "close_position",
                        "reason": "close_position tool not found",
                        "details": {}
                    }
                result = await close_tool.execute(reason=signal.reasoning or "Leader decision to close")

            # Parse result
            if isinstance(result, dict):
                # FIX: Compatible with PaperTrader and Toolkit return formats
                is_success = (
                    result.get('success') is True or
                    result.get('status') == 'success'
                )

                if is_success:
                    return {
                        "status": "success",
                        "action": "closed_position",
                        "reason": "Close position successful",
                        "details": result
                    }
                else:
                    error_msg = result.get('error') or result.get('message') or 'Close position failed'
                    return {
                        "status": "error",
                        "action": "close_position",
                        "reason": error_msg,
                        "details": result
                    }
            else:
                # result is string
                return {
                    "status": "success",
                    "action": "closed_position",
                    "reason": str(result),
                    "details": {}
                }

        # Long/Short - Open position
        if direction in ["long", "short"]:
            # FIX: Calculate actual USDT amount
            # PaperTrader needs amount_usdt, while signal provides amount_percent
            if self.paper_trader:
                # Get account balance
                account = await self.paper_trader.get_account()
                available_balance = account.get('available_balance', 0)

                # Calculate USDT amount: available_balance * amount_percent
                # Note: amount_percent is already decimal (0-1), no need to divide by 100
                amount_usdt = available_balance * signal.amount_percent

                logger.info(f"[{self.name}] Available balance: {available_balance:.2f} USDT")
                logger.info(f"[{self.name}] Position percent: {signal.amount_percent * 100:.1f}%")
                logger.info(f"[{self.name}] Open amount: {amount_usdt:.2f} USDT")

                # Prepare parameters (using amount_usdt)
                params = {
                    "symbol": signal.symbol,
                    "leverage": signal.leverage,
                    "amount_usdt": amount_usdt,  # Use USDT amount
                    "tp_price": signal.take_profit_price,
                    "sl_price": signal.stop_loss_price
                }

                # Call paper_trader directly
                if direction == "long":
                    result = await self.paper_trader.open_long(**params)
                else:
                    result = await self.paper_trader.open_short(**params)
            else:
                # Use toolkit (toolkit tools may accept amount_percent)
                params = {
                    "symbol": signal.symbol,
                    "leverage": signal.leverage,
                    "amount_percent": signal.amount_percent,
                    "take_profit_price": signal.take_profit_price,
                    "stop_loss_price": signal.stop_loss_price,
                    "reason": signal.reasoning or f"Leader decision to go {direction}"
                }

                tool_name = "open_long" if direction == "long" else "open_short"
                tool = self.toolkit._tools.get(tool_name)
                if not tool:
                    return {
                        "status": "error",
                        "action": tool_name,
                        "reason": f"{tool_name} tool not found",
                        "details": {}
                    }
                result = await tool.execute(**params)

            # Parse result
            if isinstance(result, dict):
                # FIX: PaperTrader returns success field (boolean), not status field
                # Compatible with both formats:
                # 1. PaperTrader format: {"success": True, ...}
                # 2. Toolkit format: {"status": "success", ...}
                is_success = (
                    result.get('success') is True or  # PaperTrader format
                    result.get('status') == 'success'  # Toolkit format
                )

                if is_success:
                    return {
                        "status": "success",
                        "action": f"opened_{direction}",
                        "reason": f"Open {direction} position successful",
                        "details": result
                    }
                else:
                    # Extract error message
                    error_msg = result.get('error') or result.get('message') or f'Open {direction} position failed'
                    return {
                        "status": "error",
                        "action": f"open_{direction}",
                        "reason": error_msg,
                        "details": result
                    }
            else:
                # result is string
                return {
                    "status": "success",
                    "action": f"opened_{direction}",
                    "reason": str(result),
                    "details": {}
                }

        # Unknown operation
        return {
            "status": "error",
            "action": "unknown",
            "reason": f"Unknown operation type: {direction}",
            "details": {}
        }
